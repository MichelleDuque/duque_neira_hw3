export function api() {
  //Spinner Functionality To load the api data

  const spinner = `<?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="margin: auto; background: #84996B; display: block; shape-rendering: auto;" width="330px" height="330px" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid">
<circle cx="50" cy="50" r="0" fill="none" stroke="red" stroke-width="2">
  <animate attributeName="r" repeatCount="indefinite" dur="1s" values="0;40" keyTimes="0;1" keySplines="0 0.2 0.8 1" calcMode="spline" begin="0s"></animate>
  <animate attributeName="opacity" repeatCount="indefinite" dur="1s" values="1;0" keyTimes="0;1" keySplines="0.2 0 0.8 1" calcMode="spline" begin="0s"></animate>
</circle><circle cx="50" cy="50" r="0" fill="none" stroke="blue" stroke-width="2">
  <animate attributeName="r" repeatCount="indefinite" dur="1s" values="0;40" keyTimes="0;1" keySplines="0 0.2 0.8 1" calcMode="spline" begin="-0.5s"></animate>
  <animate attributeName="opacity" repeatCount="indefinite" dur="1s" values="1;0" keyTimes="0;1" keySplines="0.2 0 0.8 1" calcMode="spline" begin="-0.5s"></animate>
</circle>
<!-- [ldio] generated by https://loading.io/ --></svg>`;

  const errorMessage =
    '<div class="error-message"><h2>Sorry There is an error</h2> <img src="images/error.gif" alt="Error Message" width="300px" height="300px"></div>';
  screen = document.querySelector("#app");

  const digimon = Vue.createApp({
    data() {
      return {
        isLoading: false,
        charactersData: [],
        count: 0,
        levels: "",
        fields: [],
        types: "",
        attributes: "",
        photo: "",
        error: "",
        showEvolutionName: false,
        spinner: spinner,
      };
    },
    created() {
      this.fetchCharactersData();
    },
    methods: {
      fetchCharactersData() {
        this.isLoading = true;
        fetch("http://localhost/digimon/public/characters")
          .then((res) => res.json())
          .then((data) => {
            this.charactersData = data;
            this.displayCharacter(0);
          })
          .catch((error) => {
            console.error(error);
            this.error = "Error fetching characters data";
            screen.innerHTML = errorMessage;
          })
          .finally(() => {
            this.isLoading = false;
          });
      },
      displayCharacter(count) {
        const character = this.charactersData[count];
        this.getDigimon(character.name);
      },
      getDigimon(whichDigimon) {
        this.isLoading = true;
        let title = whichDigimon;
        let convertedTitle = title.split(" ").join("+");

        fetch(`https://digi-api.com/api/v1/digimon/${convertedTitle}`)
          .then((res) => res.json())
          .then((data) => {
            if (data) {
              const digimon = data;
              this.error = false;
              this.levels = data.levels
                ? data.levels.map((lev) => lev.level).join(", ")
                : "Not available";
              this.fields = data.fields
                ? data.fields.map((fie) => fie.image)
                : "Not available";
              this.types = digimon.types
                ? digimon.types[0].type
                : "Not available";
              this.attributes = data.attributes
                ? data.attributes.map((attr) => attr.attribute).join(", ")
                : "Not available";
            } else {
              this.error = "No digimon found. Try Again.";
              screen.innerHTML = errorMessage;
            }
          })
          .catch((error) => {
            console.error(error);
            screen.innerHTML = errorMessage;
          })
          .finally(() => {
            this.isLoading = false;
          });
      },
      nextDigimon() {
        gsap.from("#digimonName", {
          y: 100,
          duration: 0.2,
          delay: 0.2,
          ease: "bounce",
        });

        gsap.from("#digimonLevels", {
          y: 20,
          duration: 0.2,
          delay: 0.2,
          ease: "expo.out",
        });

        gsap.from("#digimon-in-device", {
          y: 20,
          duration: 0.2,
          delay: 0.2,
          ease: "expo.out",
        });

        gsap.from("#digimonInfoCon", {
          y: 20,
          duration: 0.2,
          delay: 0.2,
          ease: "expo.out",
        });

        this.count++;
        if (this.count >= this.charactersData.length) {
          this.count = 0;
        }
        this.displayCharacter(this.count);
      },
      previousDigimon() {
        gsap.from("#digimonName", {
          y: 200,
          duration: 0.2,
          delay: 0.2,
          ease: "bounce",
        });

        gsap.from("#digimonLevels", {
          y: 20,
          duration: 0.2,
          delay: 0.2,
          ease: "expo.out",
        });

        gsap.from("#digimon-in-device", {
          y: 20,
          duration: 0.2,
          delay: 0.2,
          ease: "expo.out",
        });

        gsap.from("#digimonInfoCon", {
          y: 20,
          duration: 0.2,
          delay: 0.2,
          ease: "expo.out",
        });

        this.count--;
        if (this.count < 0) {
          this.count = this.charactersData.length - 1;
        }
        this.displayCharacter(this.count);
      },
      evolutionDigimon() {
        this.showEvolutionName = !this.showEvolutionName;
      },
    },
  });

  digimon.mount("#app");
}
